//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE_Golden_Top(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);


    //=======================================================
    //  REG/WIRE declarations
    //=======================================================

    //=======================================================
    //  Structural coding
    //=======================================================

    // sdram
    wire dram_wr_req, dram_rd_req;
    wire dram_wr_fin, dram_rd_fin;
    wire [31:0] dram_wr_data, dram_rd_data, dram_wr_addr, dram_rd_addr;

    wire reset_cmd;
    wire loader_req = SW[0];
    wire [31:0] entry;
    wire loader_idle;
    wire clk100;
    wire init_fin;

    wire locked;

    pll pll_inst(
        .areset(reset_cmd),
        .inclk0(MAX10_CLK2_50),
        .c0(clk100),
        .locked(locked)
    );

    DETECT_EDGE key0(
        .CLK(MAX10_CLK1_50),
        .KEY(KEY[0]),
        .pos(0),
        .res(reset_cmd)
    );

    SIMPLE_TEST tester(
        .clk(MAX10_CLK1_50),
        .reset(reset_cmd),

        .mode_sw(SW[0]),
        .key(KEY[1]),

        .wr_req(dram_wr_req),
        .wr_fin(dram_wr_fin),
        .wr_addr(dram_wr_addr),
        .wr_data(dram_wr_data),

        .rd_req(dram_rd_req),
        .rd_fin(dram_rd_fin),
        .rd_addr(dram_rd_addr),
        .rd_data(dram_rd_data),
        
        .tx_pin(GPIO[9])
    );
    
    wire [3:0] o_state;
    SDRAM_CONTROLLER sdram_cont(
        .clk(clk100),
        .reset(reset_cmd),
        .o_state(o_state),
        
        .init_fin(init_fin),

        .rd_req(dram_rd_req),
        .rd_addr(dram_rd_addr),
        .rd_fin(dram_rd_fin),
        .rd_data(dram_rd_data),

        .wr_req(dram_wr_req),
        .wr_addr(dram_wr_addr),
        .wr_fin(dram_wr_fin),
        .wr_data(dram_wr_data),

        //////////// SDRAM //////////
        .DRAM_ADDR(DRAM_ADDR),
        .DRAM_BA(DRAM_BA),
        .DRAM_CAS_N(DRAM_CAS_N),
        .DRAM_CKE(DRAM_CKE),
        .DRAM_CLK(DRAM_CLK),
        .DRAM_CS_N(DRAM_CS_N),
        .DRAM_DQ(DRAM_DQ),
        .DRAM_LDQM(DRAM_LDQM),
        .DRAM_RAS_N(DRAM_RAS_N),
        .DRAM_UDQM(DRAM_UDQM),
        .DRAM_WE_N(DRAM_WE_N)
    );

    wire [3:0] d2, d3, d4, d5;
    SWITCH_HL s2(dram_rd_data[ 3: 0], dram_rd_data[19:16], SW[5], d2);
    SWITCH_HL s3(dram_rd_data[ 7: 4], dram_rd_data[23:20], SW[5], d3);
    SWITCH_HL s4(dram_rd_data[11: 8], dram_rd_data[27:24], SW[5], d4);
    SWITCH_HL s5(dram_rd_data[15:12], dram_rd_data[31:28], SW[5], d5);

    SEG7_LUT u0(
        .iDIG(dram_wr_data[3:0]),
        .oSEG(HEX0)
    );
    SEG7_LUT u1(
        .iDIG(o_state),
        .oSEG(HEX1)
    );
    SEG7_LUT u2(
        .iDIG(d2),
        .oSEG(HEX2)
    );
    SEG7_LUT u3(
        .iDIG(d3),
        .oSEG(HEX3)
    );
    SEG7_LUT u4(
        .iDIG(d4),
        .oSEG(HEX4)
    );
    SEG7_LUT u5(
        .iDIG(d5),
        .oSEG(HEX5)
    );

    LED_CONT l0(reset_cmd, LEDR[0]);
    LED_CONT l1(dram_wr_req, LEDR[1]);
    LED_CONT l2(dram_wr_fin, LEDR[2]);
    LED_CONT l3(dram_rd_req, LEDR[3]);
    LED_CONT l4(dram_rd_fin, LEDR[4]);
    LED_CONT l5(init_fin, LEDR[5]);

endmodule

module SWITCH_HL(
    input wire [3:0] dl, dh,
    input wire sw,
    output wire [3:0] dout
);
    assign dout = (~sw ? dl : dh);
endmodule

module LED_CONT(
    input wire key,
    output wire led
);
    reg s = 1'b0;
    always @(posedge key) begin
        s <= ~s;
    end
    assign led = s;
endmodule

module SIMPLE_TEST(
    input wire clk,
    input wire reset,

    input wire mode_sw,
    input wire key,

    output reg wr_req,
    input wire wr_fin,
    output reg [31:0] wr_addr,
    output reg [31:0] wr_data,

    output reg rd_req,
    input wire rd_fin,
    output reg [31:0] rd_addr,
    input wire [31:0] rd_data,

    output wire tx_pin
);
    localparam WR_MODE = 1'b0;
    localparam RD_MODE = 1'b1;

    localparam TEST_IDLE = 4'd0;
    localparam TEST_WR_REQ = 4'd1;
    localparam TEST_WR_FIN = 4'd2;
    localparam TEST_RD_REQ = 4'd3;
    localparam TEST_RD_FIN = 4'd4;
    localparam TEST_TRANS_REQ = 4'd5;
    localparam TEST_TRANS_FIN = 4'd6;

    reg [3:0] state;
    reg tx_transmit;
    reg [7:0] tx_data;
    wire tx_ready;
    wire key_pulse;

    uart uart1(
        .clk(clk),
        .tx(tx_pin),
        .tx_data(tx_data),
        .tx_transmit(tx_transmit),
        .tx_ready(tx_ready)
    );

    DETECT_EDGE detect_key(
        .CLK(clk),
        .KEY(key),
        .pos(0),
        .res(key_pulse)
    );

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            wr_req      <= 1'b0;
            wr_data     <= { 16'h1234, 16'd97 };
            wr_addr     <= 32'b0;
            rd_req      <= 1'b0;
            rd_addr     <= 32'b0;
            state       <= TEST_IDLE;
            tx_transmit <= 1'b0;
        end else begin
            case (state)
                TEST_IDLE: begin
                    if (~key_pulse) begin
                        state <= TEST_IDLE;
                    end else if (mode_sw == WR_MODE) begin
                        state <= TEST_WR_REQ;
                        wr_req <= 1'b1;
                    end else if (mode_sw == RD_MODE) begin
                        state <= TEST_RD_REQ;
                        rd_req <= 1'b1;
                    end
                end
                TEST_WR_REQ: begin
                    if (wr_fin) begin
                        wr_req <= 1'b0;
                        state <= TEST_WR_FIN;
                    end else begin
                        state <= TEST_WR_REQ;
                    end
                end
                TEST_WR_FIN: begin
                    wr_data <= wr_data + 32'b1;
                    wr_addr <= wr_addr + 32'd4;
                    state <= TEST_IDLE;
                end
                TEST_RD_REQ: begin
                    if (rd_fin) begin
                        rd_req <= 1'b0;
                        state <= TEST_RD_FIN;
                    end else begin
                        state <= TEST_RD_REQ;
                    end
                end
                TEST_RD_FIN: begin
                    tx_data <= rd_data[7+16:0+16];
                    rd_addr <= rd_addr + 32'd4;
                    state <= TEST_TRANS_REQ;
                end
                TEST_TRANS_REQ: begin
                    if (tx_ready) begin
                        tx_transmit <= 1'b1;
                        state <= TEST_TRANS_FIN;
                    end else begin
                        state <= TEST_TRANS_REQ;
                    end
                end
                TEST_TRANS_FIN: begin
                    tx_transmit <= 1'b0;
                    state <= TEST_IDLE;
                end
            endcase
        end
    end
endmodule
