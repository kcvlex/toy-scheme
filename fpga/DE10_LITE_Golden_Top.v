//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`default_nettype none

module DE10_LITE_Golden_Top(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);


    //=======================================================
    //  REG/WIRE declarations
    //=======================================================
    
    // SDRAM
    wire        dram_wr_req;
    wire        dram_wr_fin;
    wire [31:0] dram_wr_data;
    wire [31:0] dram_wr_addr;
    wire        dram_rd_req;
    wire        dram_rd_fin;
    wire [31:0] dram_rd_data;
    wire [31:0] dram_rd_addr;

    // UART
    wire [7:0] rx_data;
    wire       rx_valid;
    wire [7:0] tx_data;
    wire       tx_req;
    wire       tx_ready;

    // Program Loader
    wire        pl_tx_req;
    wire [7:0]  pl_tx_data;
    wire        pl_dram_wr_req;
    wire [31:0] pl_dram_wr_addr;
    wire [31:0] pl_dram_wr_data;

    // Processor
    wire        proc_dram_wr_req;
    wire [31:0] proc_dram_wr_addr;
    wire [31:0] proc_dram_wr_data;
    wire        proc_dram_rd_req;
    wire [31:0] proc_dram_rd_addr;

    // DEBUG
    wire        dbg_tx_req;
    wire [7:0]  dbg_tx_data;
    wire        dbg_dram_rd_req;
    wire [31:0] dbg_dram_rd_addr;
    wire [31:0] dbg_mem_data;

    //=======================================================
    //  Structural coding
    //=======================================================

    localparam ENTRY_ADDR = 32'h10198;

    wire program_load = SW[0];
    wire exec_proc    = SW[1];
    wire read_program = SW[2];

    wire RST_X = ~KEY[0];

    /*
    wire clk25, clk50, clk100, clk70;
    pll pll_inst(
        .areset(RST_X),
        .inclk0(MAX10_CLK1_50),
        .c0(clk100),
        .c1(clk50),
        .c2(clk25),
        .c3(clk70)
    );
    */

    uart uart1(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),

        .rx(GPIO[7]),
        .rx_data(rx_data),
        .rx_valid(rx_valid),

        .tx(GPIO[9]),
        .tx_data(tx_data),
        .tx_transmit(tx_req),
        .tx_ready(tx_ready)
    );

    PROGRAM_LOADER pl(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),

        .req(program_load),

        .rx_ack(rx_valid),
        .rx_data(rx_data),
        .tx_ready(tx_ready),
        .tx_req(pl_tx_req),
        .tx_data(pl_tx_data),

        .wr_req(pl_dram_wr_req),
        .wr_fin(dram_wr_fin),
        .wr_addr(pl_dram_wr_addr),
        .wr_data(pl_dram_wr_data)
    );

    localparam MEM_START = 32'h10010;
    wire [31:0] rd_start = (SW[9] ? MEM_START : ENTRY_ADDR);
    SIMPLE_READ tester(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),

        .sw(read_program),
        .key(KEY[1]),

        .rd_req(dbg_dram_rd_req),
        .rd_fin(dram_rd_fin),
        .rd_addr(dbg_dram_rd_addr),
        .rd_data(dram_rd_data),
        .rd_addr_init(rd_start),
        .dout(dbg_mem_data)
    );
   
    wire [3:0] o_state;
    SDRAM_CONTROLLER sdram_cont(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),
        .o_state(o_state),

        .rd_req(dram_rd_req),
        .rd_addr(dram_rd_addr),
        .rd_fin(dram_rd_fin),
        .rd_data(dram_rd_data),

        .wr_req(dram_wr_req),
        .wr_addr(dram_wr_addr),
        .wr_fin(dram_wr_fin),
        .wr_data(dram_wr_data),

        //////////// SDRAM //////////
        .DRAM_ADDR(DRAM_ADDR),
        .DRAM_BA(DRAM_BA),
        .DRAM_CAS_N(DRAM_CAS_N),
        .DRAM_CKE(DRAM_CKE),
        .DRAM_CLK(DRAM_CLK),
        .DRAM_CS_N(DRAM_CS_N),
        .DRAM_DQ(DRAM_DQ),
        .DRAM_LDQM(DRAM_LDQM),
        .DRAM_RAS_N(DRAM_RAS_N),
        .DRAM_UDQM(DRAM_UDQM),
        .DRAM_WE_N(DRAM_WE_N)
    );

    wire display;
    wire [31:0] display_data;
    wire [31:0] PC;
    wire [3:0] state;
    wire [31:0] reorder_rd_data = { dram_rd_data[15:0], dram_rd_data[31:16] };
    wire [31:0] o_instr;
    PROCESSOR proc(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),

        .state(state),
        .PC(PC),
        .o_instr(o_instr),
        .req(exec_proc),

        .entry_addr(ENTRY_ADDR),

        .dram_wr_req(proc_dram_wr_req),
        .dram_wr_fin(dram_wr_fin),
        .dram_wr_addr(proc_dram_wr_addr),
        .dram_wr_data(proc_dram_wr_data),

        .dram_rd_req(proc_dram_rd_req),
        .dram_rd_fin(dram_rd_fin),
        .dram_rd_addr(proc_dram_rd_addr),
        .dram_rd_data(reorder_rd_data),

        .display(display),
        .display_data(display_data)
    );

    reg [31:0] hpre_dram_rd_data;
    always @(posedge MAX10_CLK1_50 or posedge RST_X) begin
        if (RST_X) begin
            hpre_dram_rd_data <= 32'b0;
        end else begin
            hpre_dram_rd_data <= dram_rd_data;
        end
    end
    wire [31:0] log = (SW[5] ? hpre_dram_rd_data : dram_rd_addr);
    PC_LOG pclog(
        .clk(MAX10_CLK1_50),
        .reset(RST_X),
        .pc(log),
        .tx_ready(tx_ready),
        .tx_req(dbg_tx_req),
        .tx_data(dbg_tx_data)
    );
    
    assign tx_req       = program_load ? pl_tx_req
                        : exec_proc    ? dbg_tx_req
                        :                1'b0;
    assign tx_data      = program_load ? pl_tx_data
                        : exec_proc    ? dbg_tx_data
                        :                8'b0;
    assign dram_wr_req  = program_load ? pl_dram_wr_req
                        : exec_proc    ? proc_dram_wr_req
                        :                1'b0;
    assign dram_wr_addr = program_load ? pl_dram_wr_addr
                        : exec_proc    ? proc_dram_wr_addr
                        :                32'b0;
    assign dram_wr_data = program_load ? pl_dram_wr_data
                        : exec_proc    ? proc_dram_wr_data
                        :                32'b0;
    assign dram_rd_req  = exec_proc    ? proc_dram_rd_req
                        : read_program ? dbg_dram_rd_req
                        :                1'b0;
    assign dram_rd_addr = exec_proc    ? proc_dram_rd_addr
                        : read_program ? dbg_dram_rd_addr
                        :                32'b0;

    wire [23:0] seg7_data = read_program ? { dbg_mem_data[7:0], dbg_mem_data[31:16] }
                          : display      ? { state, display_data[19:0] }
                          :                PC[23:0];
    wire [3:0] d0 = seg7_data[ 3: 0];
    wire [3:0] d1 = seg7_data[ 7: 4];
    wire [3:0] d2 = seg7_data[11: 8];
    wire [3:0] d3 = seg7_data[15:12];
    wire [3:0] d4 = seg7_data[19:16];
    wire [3:0] d5 = seg7_data[23:20];

    SEG7_LUT u0(
        .iDIG(d0),
        .oSEG(HEX0),
        .none(1'b0)
    );
    SEG7_LUT u1(
        .iDIG(d1),
        .oSEG(HEX1),
        .none(1'b0)
    );
    SEG7_LUT u2(
        .iDIG(d2),
        .oSEG(HEX2),
        .none(1'b0)
    );
    SEG7_LUT u3(
        .iDIG(d3),
        .oSEG(HEX3),
        .none(1'b0)
    );
    SEG7_LUT u4(
        .iDIG(d4),
        .oSEG(HEX4),
        .none(1'b0)
    );
    SEG7_LUT u5(
        .iDIG(d5),
        .oSEG(HEX5),
        .none(1'b0)
    );

    LED_CONT l0(RST_X, LEDR[0]);
    LED_CONT l1(dram_wr_req, LEDR[1]);
    //LED_CONT l2(dram_wr_fin, LEDR[2]);
    LED_CONT l3(dram_rd_req, LEDR[3]);
    //LED_CONT l4(dram_rd_fin, LEDR[4]);
endmodule

module SWITCH_HL(
    input wire [3:0] dl, dh,
    input wire sw,
    output wire [3:0] dout
);
    assign dout = (~sw ? dl : dh);
endmodule

module LED_CONT(
    input wire key,
    output wire led
);
    reg s = 1'b0;
    always @(posedge key) begin
        s <= ~s;
    end
    assign led = s;
endmodule

module PC_LOG(
    input wire clk,
    input wire reset,
    input wire [31:0] pc,
    input wire tx_ready,
    output reg tx_req,
    output reg [7:0] tx_data
);
    reg [3:0] rem;
    reg [31:0] data, buffer;
    reg idle, hpre_idle;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            idle <= 1'b1;
            data <= 32'b0;
        end else begin
            if (idle && data != pc) begin
                data <= pc;
                idle <= 1'b0;
            end else if (~idle && rem == 4'b0) begin
                idle <= 1'b1;
            end
        end
    end

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            hpre_idle <= 1'b1;
            rem <= 4'b0;
            buffer <= 32'b0;
            tx_req <= 1'b0;
        end else begin
            if (hpre_idle && ~idle) begin
                rem <= 4'd4;
                buffer <= data;
            end else if (~hpre_idle && 4'b0 < rem) begin
                if (tx_ready) begin
                    tx_req <= 1'b1;
                    tx_data <= buffer[31:24];
                    buffer <= buffer << 8;
                    rem <= rem - 4'b1;
                end else begin
                    tx_req <= 1'b0;
                end
            end else if (~hpre_idle && idle) begin
                tx_req <= 1'b0;
            end
            hpre_idle <= idle;
        end
    end
endmodule

module SIMPLE_READ(
    input wire clk,
    input wire reset,

    input wire sw,
    input wire key,

    input wire rd_fin,
    output reg rd_req,
    output reg [31:0] rd_addr,
    input wire [31:0] rd_data,
    input wire [31:0] rd_addr_init,
    output reg [31:0] dout
);
    wire key_pulse;
    DETECT_NEGEDGE detect_key(
        .CLK(clk),
        .RESET(reset),
        .SIGNAL(key),
        .EDGE(key_pulse),
    );

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            rd_req <= 1'b0;
            rd_addr <= rd_addr_init;
            dout <= 32'b0;
        end else if (sw) begin
            if (~rd_req) begin
                if (key_pulse) begin
                    rd_req <= 1'b1;
                end
            end else begin
                if (rd_fin) begin
                    rd_req <= 1'b0;
                    rd_addr <= rd_addr + 32'd4;
                    dout <= rd_data;
                end
            end
        end
    end
endmodule
