$date
	Mon Dec 21 18:09:09 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module top $end
$scope module p $end
$var wire 1 ! CLK $end
$var wire 1 " RST_X $end
$var wire 32 # instr [31:0] $end
$var reg 32 $ PC [31:0] $end
$scope module cpu $end
$var wire 1 ! CLK $end
$var wire 32 % PC [31:0] $end
$var wire 1 " RST_X $end
$var wire 1 & we $end
$var wire 5 ' rs2 [4:0] $end
$var wire 5 ( rs1 [4:0] $end
$var wire 32 ) rrs2 [31:0] $end
$var wire 32 * rrs1 [31:0] $end
$var wire 32 + result [31:0] $end
$var wire 5 , rd [4:0] $end
$var wire 5 - instr_type [4:0] $end
$var wire 3 . instr_format [2:0] $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 imm [31:0] $end
$var wire 7 1 funct7 [6:0] $end
$var wire 3 2 funct3 [2:0] $end
$var wire 32 3 a0 [31:0] $end
$scope module alu $end
$var wire 1 ! CLK $end
$var wire 1 " RST_X $end
$var wire 32 4 w_res [31:0] $end
$var wire 32 5 s_rrs2 [31:0] $end
$var wire 32 6 s_rrs1 [31:0] $end
$var wire 32 7 s_imm [31:0] $end
$var wire 32 8 rrs2 [31:0] $end
$var wire 32 9 rrs1 [31:0] $end
$var wire 5 : instr_type [4:0] $end
$var wire 32 ; imm [31:0] $end
$var wire 7 < funct7 [6:0] $end
$var wire 3 = funct3 [2:0] $end
$var reg 32 > r_res [31:0] $end
$upscope $end
$scope module decoder $end
$var wire 5 ? rs2 [4:0] $end
$var wire 5 @ rs1 [4:0] $end
$var wire 5 A rd [4:0] $end
$var wire 5 B opcode [4:0] $end
$var wire 5 C instr_type [4:0] $end
$var wire 3 D instr_format [2:0] $end
$var wire 32 E instr [31:0] $end
$var wire 32 F imm [31:0] $end
$var wire 7 G funct7 [6:0] $end
$var wire 3 H funct3 [2:0] $end
$scope module extend_imm $end
$var wire 3 I instr_format [2:0] $end
$var wire 32 J instr [31:0] $end
$var wire 20 K imm20 [19:0] $end
$var wire 13 L imm13 [12:0] $end
$var wire 12 M imm12 [11:0] $end
$var wire 32 N imm [31:0] $end
$upscope $end
$scope module instr_t $end
$var wire 5 O opcode [4:0] $end
$var wire 5 P instr_type [4:0] $end
$var wire 3 Q instr_format [2:0] $end
$var wire 2 R base_opcode_map_row [1:0] $end
$var wire 3 S base_opcode_map_col [2:0] $end
$scope function f $end
$var reg 2 T in0 [1:0] $end
$var reg 3 U in1 [2:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module regfile $end
$var wire 1 ! CLK $end
$var wire 1 " RST_X $end
$var wire 5 V rd [4:0] $end
$var wire 5 W rs1 [4:0] $end
$var wire 5 X rs2 [4:0] $end
$var wire 32 Y wd [31:0] $end
$var wire 1 & we $end
$var wire 32 Z rrs2 [31:0] $end
$var wire 32 [ rrs1 [31:0] $end
$var wire 32 \ a0 [31:0] $end
$upscope $end
$upscope $end
$scope module imem $end
$var wire 1 ! CLK $end
$var wire 1 " RST_X $end
$var wire 32 ] addr [31:0] $end
$var wire 32 ^ out_data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
x&
bx %
bx $
bx #
0"
1!
$end
#5
b0 >
b0 #
b0 /
b0 E
b0 J
b0 ^
b0 *
b0 6
b0 9
b0 [
b0 3
b0 \
b0 )
b0 5
b0 8
b0 Z
bx0 K
bx0 L
#10
b0 -
b0 :
b0 C
b0 P
b0 .
b0 D
b0 I
b0 Q
b0 +
b0 4
b0 Y
b0 K
b0 M
b0 L
b0 B
b0 O
b0 1
b0 <
b0 G
b0 2
b0 =
b0 H
b0 ,
b0 A
b0 V
b0 '
b0 ?
b0 X
b0 (
b0 @
b0 W
#15
b0 U
b0 T
1&
b0 0
b0 7
b0 ;
b0 F
b0 N
b0 R
b0 S
#25
b1 .
b1 D
b1 I
b1 Q
#50
0!
#100
1!
#125
1"
#130
b0 $
b0 %
b0 ]
bx *
bx 6
bx 9
bx [
bx )
bx 5
bx 8
bx Z
bx 3
bx \
bx #
bx /
bx E
bx J
bx ^
#135
b0 #
b0 /
b0 E
b0 J
b0 ^
b0 *
b0 6
b0 9
b0 [
b0 )
b0 5
b0 8
b0 Z
bx M
bx B
bx O
bx 1
bx <
bx G
bx 2
bx =
bx H
bx ,
bx A
bx V
bx '
bx ?
bx X
bx (
bx @
bx W
#140
bx U
bx T
b0 M
bx 0
bx 7
bx ;
bx F
bx N
b0 B
b0 O
b0 1
b0 <
b0 G
b0 2
b0 =
b0 H
b0 ,
b0 A
b0 V
b0 '
b0 ?
b0 X
b0 (
b0 @
b0 W
bx R
bx S
bx )
bx 5
bx 8
bx Z
bx *
bx 6
bx 9
bx [
#145
b0 U
b0 T
b0 0
b0 7
b0 ;
b0 F
b0 N
b0 R
b0 S
b0 )
b0 5
b0 8
b0 Z
b0 *
b0 6
b0 9
b0 [
#150
b0 .
b0 D
b0 I
b0 Q
0!
#155
b1 .
b1 D
b1 I
b1 Q
#200
1!
#205
b100 $
b100 %
b100 ]
#210
b101000000000001010010011 #
b101000000000001010010011 /
b101000000000001010010011 E
b101000000000001010010011 J
b101000000000001010010011 ^
#215
b1010 M
b100 B
b100 O
b101 ,
b101 A
b101 V
b1010 '
b1010 ?
b1010 X
#220
b100 U
b1010 0
b1010 7
b1010 ;
b1010 F
b1010 N
b100 S
bx )
bx 5
bx 8
bx Z
#230
b100 -
b100 :
b100 C
b100 P
#235
b1010 >
#240
b1010 +
b1010 4
b1010 Y
#250
0!
#300
1!
#305
b1000 $
b1000 %
b1000 ]
#310
b10000000000000001100010011 #
b10000000000000001100010011 /
b10000000000000001100010011 E
b10000000000000001100010011 J
b10000000000000001100010011 ^
#315
b100000 M
b1 1
b1 <
b1 G
b110 ,
b110 A
b110 V
b0 '
b0 ?
b0 X
#320
b100000 0
b100000 7
b100000 ;
b100000 F
b100000 N
b0 )
b0 5
b0 8
b0 Z
#325
b100000 >
#330
b100000 +
b100000 4
b100000 Y
#350
0!
#400
1!
#405
b1100 $
b1100 %
b1100 ]
#410
b11000101000001110110011 #
b11000101000001110110011 /
b11000101000001110110011 E
b11000101000001110110011 J
b11000101000001110110011 ^
#415
b110 M
b1100 B
b1100 O
b0 1
b0 <
b0 G
b111 ,
b111 A
b111 V
b110 '
b110 ?
b110 X
b101 (
b101 @
b101 W
#420
b1 T
b110 0
b110 7
b110 ;
b110 F
b110 N
b1 R
b100000 )
b100000 5
b100000 8
b100000 Z
b1010 *
b1010 6
b1010 9
b1010 [
#425
b10000 >
#430
b1100 -
b1100 :
b1100 C
b1100 P
b0 .
b0 D
b0 I
b0 Q
b10000 +
b10000 4
b10000 Y
#435
b101010 >
b0 0
b0 7
b0 ;
b0 F
b0 N
b0 M
#440
b101010 +
b101010 4
b101010 Y
#450
0!
#500
1!
#505
b10000 $
b10000 %
b10000 ]
#510
bx #
bx /
bx E
bx J
bx ^
#515
bx B
bx O
bx 1
bx <
bx G
bx 2
bx =
bx H
bx ,
bx A
bx V
bx '
bx ?
bx X
bx (
bx @
bx W
#520
b0 >
bx U
bx T
bx R
bx S
bx )
bx 5
bx 8
bx Z
bx *
bx 6
bx 9
bx [
#525
b0 +
b0 4
b0 Y
#530
b0 -
b0 :
b0 C
b0 P
#550
0!
#600
1!
#605
b10100 $
b10100 %
b10100 ]
#650
0!
#700
1!
#705
b11000 $
b11000 %
b11000 ]
#750
0!
#800
1!
#805
b11100 $
b11100 %
b11100 ]
#850
0!
#900
1!
